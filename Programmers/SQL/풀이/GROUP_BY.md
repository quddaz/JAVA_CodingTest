
> LV.3 카테고리 별 도서 판매량 집계하기

```sql
SELECT B.CATEGORY, SUM(SALES) AS TOTAL_SALES
FROM BOOK B
JOIN BOOK_SALES S ON B.BOOK_ID = S.BOOK_ID
WHERE S.SALES_DATE LIKE '2022-01-%'
GROUP BY B.CATEGORY
ORDER BY 1 ASC
```


> LV.3 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기

```sql
WITH TEMP AS (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) BETWEEN 8 AND 11
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
)
SELECT MONTH(START_DATE) AS MONTH, CAR_ID, COUNT(*) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE CAR_ID IN (SELECT CAR_ID FROM TEMP) AND MONTH(START_DATE) BETWEEN 8 AND 11
GROUP BY MONTH(START_DATE), CAR_ID
ORDER BY MONTH(START_DATE) ASC, CAR_ID DESC;
```

> LV.3 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기

```sql
WITH TEMP AS(
SELECT DISTINCT CAR_ID
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE <= '2022-10-16' AND END_DATE >= '2022-10-16'
)

SELECT CAR_ID, 
       CASE 
           WHEN CAR_ID IN (SELECT CAR_ID FROM TEMP) THEN '대여중' 
           ELSE '대여 가능' 
       END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC;
```

> LV.4 저자 별 카테고리 별 매출액 집계하기

```sql
WITH TEMP AS(
SELECT  B.CATEGORY, B.AUTHOR_ID, SUM(B.PRICE * S.SALES) AS TOTAL_SALE
FROM BOOK B
JOIN BOOK_SALES S ON B.BOOK_ID = S.BOOK_ID AND YEAR(S.SALES_DATE) = 2022 AND MONTH(S.SALES_DATE) = 1
GROUP BY B.CATEGORY, B.AUTHOR_ID
)
SELECT A.AUTHOR_ID, A.AUTHOR_NAME, T.CATEGORY, T.TOTAL_SALE
FROM AUTHOR A
JOIN TEMP T ON A.AUTHOR_ID = T.AUTHOR_ID
ORDER BY 1 ASC, 3 DESC
```


> LV.4 식품분류별 가장 비싼 식품의 정보 조회하기

```sql
WITH TEMP AS(
SELECT CATEGORY, MAX(PRICE) AS MAX_PRICE
FROM FOOD_PRODUCT
GROUP BY CATEGORY
HAVING CATEGORY IN ('과자','국', '김치', '식용유')
)

SELECT F.CATEGORY, F.PRICE AS MAX_PRICE, F.PRODUCT_NAME
FROM FOOD_PRODUCT F
JOIN TEMP T ON T.CATEGORY = F.CATEGORY AND F.PRICE = T.MAX_PRICE
ORDER BY 2 DESC
```

> LV.3 즐겨찾기가 가장 많은 식당 정보 출력하기

```sql
WITH TEMP AS(
    SELECT FOOD_TYPE, MAX(FAVORITES) AS MAX_FAVORITES
    FROM REST_INFO
    GROUP BY FOOD_TYPE
)
SELECT F.FOOD_TYPE, F.REST_ID, F.REST_NAME, F.FAVORITES
FROM REST_INFO F
JOIN TEMP T ON F.FOOD_TYPE = T.FOOD_TYPE AND F.FAVORITES = T.MAX_FAVORITES
ORDER BY 1 DESC
```

> LV.4 년, 월, 성별 별 상품 구매 회원 수 구하기

```sql
SELECT YEAR(S.SALES_DATE) AS YEAR, MONTH(S.SALES_DATE) AS MONTH,I.GENDER ,COUNT(DISTINCT S.USER_ID) AS USERS
FROM ONLINE_SALE S
JOIN USER_INFO I ON S.USER_ID = I.USER_ID
WHERE I.GENDER IS NOT NULL
GROUP BY YEAR(S.SALES_DATE), MONTH(S.SALES_DATE), I.GENDER
ORDER BY 1 ASC, 2 ASC, I.GENDER ASC
```

> LV.4 입양 시각 구하기(2)

```sql
WITH RECURSIVE HOURS AS (
    SELECT 0 AS HOUR
    UNION ALL
    SELECT HOUR + 1 FROM HOURS WHERE HOUR < 23
) 

SELECT H.HOUR, 
       CASE WHEN COUNT(DISTINCT O.ANIMAL_ID) IS NULL THEN 0 ELSE COUNT(DISTINCT O.ANIMAL_ID) END  AS COUNT
FROM HOURS H
LEFT JOIN ANIMAL_OUTS O ON H.HOUR = HOUR(O.DATETIME) 
GROUP BY H.HOUR
ORDER BY H.HOUR ASC; 

```

> LV.3 조건에 맞는 사용자와 총 거래금액 조회하기

```sql
SELECT U.USER_ID, U.NICKNAME, SUM(B.PRICE) AS TOTAL_SALES
FROM USED_GOODS_USER U
JOIN USED_GOODS_BOARD B ON U.USER_ID = B.WRITER_ID AND B.STATUS = 'DONE'
GROUP BY U.USER_ID
HAVING SUM(B.PRICE) >= 700000
ORDER BY 3 ASC
```

> LV.4 언어별 개발자 분류하기

```sql
WITH FRONT AS (
    SELECT CODE
    FROM SKILLCODES
    WHERE CATEGORY = 'Front End'
),
TEMP AS (
    SELECT  
CASE WHEN EXISTS (SELECT CODE FROM FRONT WHERE SKILL_CODE & CODE > 0) 
AND SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'Python') > 0 THEN 'A'
WHEN SKILL_CODE & (SELECT CODE FROM SKILLCODES WHERE NAME = 'C#') > 0 THEN 'B'
WHEN EXISTS (SELECT CODE FROM FRONT WHERE SKILL_CODE & CODE > 0)  THEN 'C'
ELSE NULL
        END AS GRADE, 
        ID, 
        EMAIL
    FROM DEVELOPERS
)

SELECT GRADE, ID, EMAIL
FROM TEMP
WHERE GRADE IS NOT NULL
ORDER BY 1, 2;
```

> LV.4 연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기

```sql
WITH TEMP AS (
    SELECT EMP_NO, AVG(SCORE) AS SCORE
    FROM HR_GRADE
    WHERE YEAR = 2022
    GROUP BY EMP_NO
),
MAIN AS (
    SELECT E.EMP_NO, E.EMP_NAME,
           CASE 
               WHEN G.SCORE >= 96 THEN 'S'
               WHEN G.SCORE >= 90 THEN 'A'
               WHEN G.SCORE >= 80 THEN 'B'
               ELSE 'C' 
           END AS GRADE,
           CASE 
               WHEN G.SCORE >= 96 THEN E.SAL * 0.2
               WHEN G.SCORE >= 90 THEN E.SAL * 0.15
               WHEN G.SCORE >= 80 THEN E.SAL * 0.1
               ELSE 0 
           END AS BONUS
    FROM HR_EMPLOYEES E
    JOIN TEMP G ON G.EMP_NO = E.EMP_NO
)

SELECT EMP_NO, EMP_NAME, GRADE, BONUS
FROM MAIN
ORDER BY EMP_NO;

```

