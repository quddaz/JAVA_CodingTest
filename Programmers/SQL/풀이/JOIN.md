> LV.4 특정 기간동안 대여 가능한 자동차들의 대여비용 구하기

 ```sql
SELECT 
    C.CAR_ID, 
    C.CAR_TYPE, 
    ROUND(C.DAILY_FEE * 30 * (1 - P.DISCOUNT_RATE / 100)) AS FEE
FROM 
    CAR_RENTAL_COMPANY_CAR C
JOIN 
    CAR_RENTAL_COMPANY_DISCOUNT_PLAN P 
    ON C.CAR_TYPE = P.CAR_TYPE 
    AND P.DURATION_TYPE = '30일 이상'
WHERE 
    C.CAR_TYPE IN ('세단', 'SUV')
    AND C.CAR_ID NOT IN (
        SELECT CAR_ID
        FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
        WHERE (START_DATE <= '2022-11-30' AND END_DATE >= '2022-11-01')
    )
    AND ROUND(C.DAILY_FEE * 30 * (1 - P.DISCOUNT_RATE / 100)) BETWEEN 500000 AND 1999999
ORDER BY 
    FEE DESC, 
    C.CAR_TYPE ASC, 
    C.CAR_ID DESC;
```

> LV.4 5월 식품들의 총매출 조회하기 

 ```sql
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, SUM(P.PRICE * O.AMOUNT) AS TOTAL_SALES
FROM FOOD_PRODUCT P
JOIN FOOD_ORDER O ON O.PRODUCT_ID = P.PRODUCT_ID AND O.PRODUCE_DATE LIKE '2022-05%'
GROUP BY P.PRODUCT_NAME
ORDER BY 3 DESC, 1 ASC
```

> LV.4 주문량이 많은 아이스크림들 조회하기  

 ```sql
WITH RANK_ICE AS (
    SELECT FLAVOR, SUM(TOTAL_ORDER) AS TOTAL_ORDER
    FROM (
        SELECT FLAVOR, TOTAL_ORDER FROM FIRST_HALF
        UNION ALL 
        SELECT FLAVOR, TOTAL_ORDER FROM JULY
    ) AS COMBINED
    GROUP BY FLAVOR
)
SELECT FLAVOR
FROM RANK_ICE
ORDER BY TOTAL_ORDER DESC
LIMIT 3;
```

> LV.2 조건에 맞는 도서와 저자 리스트 출력하기 

 ```sql
SELECT B.BOOK_ID, A.AUTHOR_NAME, DATE_format(B.PUBLISHED_DATE, '%Y-%m-%d') AS PUBLISHED_DATE
FROM BOOK B
JOIN AUTHOR A ON B.AUTHOR_ID = A.AUTHOR_ID
WHERE CATEGORY = '경제'
ORDER BY 3 ASC
```

> LV.4 그룹별 조건에 맞는 식당 목록 출력하기

 ```sql
WITH MEMBER_COUNT AS (
    SELECT P.MEMBER_ID, COUNT(*) AS TOTAL
    FROM MEMBER_PROFILE P
    JOIN REST_REVIEW R ON P.MEMBER_ID = R.MEMBER_ID
    GROUP BY P.MEMBER_ID
    ORDER BY TOTAL DESC
    LIMIT 1
)
SELECT P.MEMBER_NAME, R.REVIEW_TEXT, DATE_FORMAT(R.REVIEW_DATE, '%Y-%m-%d') AS REVIEW_DATE
FROM MEMBER_PROFILE P
JOIN REST_REVIEW R ON P.MEMBER_ID = R.MEMBER_ID
WHERE P.MEMBER_ID IN (SELECT MEMBER_ID FROM MEMBER_COUNT)
ORDER BY R.REVIEW_DATE ASC, R.REVIEW_TEXT ASC;
```

> LV.3 없어진 기록 찾기

 ```sql
SELECT ANIMAL_ID, NAME
FROM ANIMAL_OUTS
WHERE ANIMAL_ID NOT IN (SELECT ANIMAL_ID FROM ANIMAL_INS)
```
> LV.3 있었는데요 없었습니다.

 ```sql
SELECT I.ANIMAL_ID, I.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE I.DATETIME > O.DATETIME
ORDER BY I.DATETIME ASC
```

> LV.3 오랜기간 보호한 동물(1)

 ```sql
SELECT NAME, DATETIME
FROM ANIMAL_INS 
WHERE ANIMAL_ID NOT IN (SELECT ANIMAL_ID FROM ANIMAL_OUTS)
ORDER BY 2 ASC
LIMIT 3
```

> LV.4 보호소에서 중성화한 동물

 ```sql
SELECT I.ANIMAL_ID, I.ANIMAL_TYPE, I.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O ON O.ANIMAL_ID = I.ANIMAL_ID
WHERE I.SEX_UPON_INTAKE LIKE 'Intact%' 
AND (O.SEX_UPON_OUTCOME LIKE 'Spayed%' OR O.SEX_UPON_OUTCOME LIKE 'Neutered%');
```

> LV.2 상품 별 오프라인 매출 구하기 

 ```sql
WITH TOTAL_SALE AS(
SELECT PRODUCT_ID, SUM(SALES_AMOUNT) AS TOTAL
FROM OFFLINE_SALE
GROUP BY PRODUCT_ID
)

SELECT P.PRODUCT_CODE,  (P.PRICE * T.TOTAL) AS SALES
FROM PRODUCT P
JOIN TOTAL_SALE T ON P.PRODUCT_ID = T.PRODUCT_ID
ORDER BY 2 DESC, 1 ASC
```

> LV.5 상품을 구매한 회원 비율 구하기 

 ```sql
WITH FILTERED_USERS AS (
    SELECT USER_ID 
    FROM USER_INFO 
    WHERE YEAR(JOINED) = 2021
)
SELECT 
    YEAR(O.SALES_DATE) AS YEAR,  
    MONTH(O.SALES_DATE) AS MONTH, 
    COUNT(DISTINCT O.USER_ID) AS PURCHASED_USERS, 
    ROUND(
        COUNT(DISTINCT O.USER_ID) / (SELECT COUNT(*) FROM FILTERED_USERS), 1
    ) AS PURCHASED_RATIO
FROM ONLINE_SALE O
JOIN FILTERED_USERS U ON O.USER_ID = U.USER_ID
GROUP BY YEAR(O.SALES_DATE), MONTH(O.SALES_DATE)
ORDER BY YEAR ASC, MONTH ASC;
```
> LV.4 FrontEnd 개발자 찾기

 ```sql
SELECT DISTINCT D.ID, D.EMAIL, D.FIRST_NAME, D.LAST_NAME
FROM DEVELOPERS D
JOIN SKILLCODES S 
ON (D.SKILL_CODE & S.CODE) > 0
WHERE S.CATEGORY = 'Front End'
ORDER BY D.ID ASC;

```

